#!/usr/bin/python3

import sys
from yaml import safe_load as yload, safe_dump as ydump
import subprocess

installconf = "/root/config"

def error(src, msg):
    print(f"error: {msg} ({src})")
    sys.exit(1)

def todo(src):
    error(src, "not implemented")


with open("/root/choices.yml") as f:
    config = yload(f)

def get(path):
    "'a.b.c' -> ['a']['b']['c']"
    c = config
    keys = path.split(".")
    for key in keys:
        c = c[key]
    return c

def system(cmd, stdin=None, stderr=False):
    "stdout[, stderr], errcode = system(command[, stdin][, stderr=True])"
    # merge stdout and stderr, and return error code instead
    if stdin is not None:
        stdin = stdin.encode()
    process = subprocess.Popen(cmd, shell=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE if stderr else subprocess.STDOUT)
    out, err = process.communicate(stdin)
    returncode = process.returncode
    if stderr:
        return out.decode(), err.decode(), returncode
    else:
        return out.decode(), returncode


def systemp(cmd, stdin=None, stderr=False):
    print("running:")
    print(cmd)
    results = system(cmd, stdin, stderr)
    if stderr:
        out, err, code = results
        print("stdout:")
        print(out)
        print("stderr:")
        print(err)
        print("return code:")
        print(code)
        return out, err, code
    else:
        out, code = results
        print("stdout:")
        print(out)
        print("return code:")
        print(code)
        return out, code


verbose = get('settings.installer.verbose')

# wrappers for system() calls


def do(cmd, expected_code=0):
    "fire and forget"
    output, code = system(cmd)
    if code == expected_code:
        if verbose:
            print(f"running: {cmd}")
        return output
    else:
        print("error running:")
        print(cmd)
        print(f"return code: {code}")
        print("output:")
        print(output)
        raise AssertionError("command did not run as expected")


class pkg:
    installed = []
    def add(*pkgs):
        for pkg in pkgs:
            do(f"apk add {pkg}")
            pkg.installed.append(pkg)

    def remove(*pkgs):
        for pkg in pkgs:
            do(f"apk del {pkg}")

def persist(path):
    # saves filesystem changes to persist after install and reboot
    do(f"lbu add {path}")



#===============
# dependency checks
#===============

# TODO

#if [ $(config 'graphics.preset') = "river" ] && ! enabled 'system.repository.apk.edge-testing'
#then
#    error system.repository.apk.edge-testing "riverwm requires enabling the apk edge/testing repository"
#fi
#
#if enabled 'packages.alpine-zsh-config' && ! enabled 'packages.zsh'
#then
#    echo "warning: installing zsh default config but not zsh"
#fi
#
#for pkg in bash wget curl
#do
#    if enabled 'patches.archroot' && ! enabled "packages.$pkg"
#    then
#    	error packages.$pkg "the arch chroot requires $pkg"
#    fi
#done

#=====================
# install dependencies
#=====================


# TODO: remove from the chroot after disk-setup
pkg.add("parted", "wipefs", "arch-install-scripts")
fs = get("settings.install.filesystem")
if fs == "btrfs":
    pkg.add("btrfs-progs")
elif fs == "ext4":
    pkg.add("e2fsprogs")


if get("settings.install.mode") == "full":
    pkg.add("mkinitfs")


#===============
# alpine install
#===============


# system settings to do before installing

# TODO: move in chroot

# keyboard
layout = get('settings.user.keyboard.layout')
variant = get('settings.user.keyboard.variant')
if variant == layout:
    do(f"setup-keymap {layout} {variant}")
else:
    do(f"setup-keymap {layout} {layout}-{variant}")
# hostname
hostname = get("settings.user.hostname")
do(f"setup-hostname {hostname}")
do(f"rc-service hostname restart")
# timezone
timezone = get("settings.user.timezone")
do(f"setup-timezone {timezone}")
# apk repos
mirror = get("settings.system.repository.apk.mirror")
switch = {
    "default": "-1",
    "fastest": "-f",
    "random": "-r",
}
args = switch[mirror]
if get("settings.system.repository.apk.community"):
    args += " -c"
do(f"setup-apkrepos {args}")
# this repository is added differently because the setup-apkrepos script does not have an option for test repos
if get("settings.system.repository.apk.edge-testing"):
    url = do("cat /etc/apk/repositories | tail -n 1 | cut -d / -f 1-4")
    edge_testing = f"{url}/edge/testing"
    do(f"echo {edge_testing} >> /etc/apk/repositories")

# TODO: move this after chroot

# main user
username = get("settings.user.username")
password = get("settings.user.password")
fullname = get("settings.user.fullname")
# -a: admin (using this installs doas automatically)
# -g: groups
do(f"""setup-user -a -g 'audio video netdev' -f "{fullname}" "{username}" """)
# networkmanager uses the plugdev group for rootless interface management
if get("features.system.networkmanager"):
    do(f"adduser {username} plugdev")

# set the password for the user
# TODO: replace "echo |" with stdin=
do(f'echo "{username}:{password}" | chpasswd')
persist(f"/home/{username}")




# ========
# simple efi manual install
# ========


def getram():
    "return ram size in MB"
    return int(do("free -m | tr -s ' ' | head -n 2 | tail -n 1 | cut -d ' ' -f 2"))


def getswap(swaptype):
    "return desired swap size"
    swap = get(f"settings.install.swap.{swaptype}")
    if swap == "none":
        return 0
    elif swap == "auto":
        size = getram()
    elif swap[-1] == "G":
        # 0.5G -> 512 (M)
        size = int(float(swap[:-1]) * 1024)
    else:
        size = int(swap[:-1])

    return size



device = get('settings.install.device')
if device == "auto":
    pkg.add("lsblk")
    out = do("lsblk -r -no NAME,TYPE | grep disk | cut -d ' ' -f 1")
    dev = out.split("\n")[0]
    device = f"/dev/{dev}"
    print(f"installing on {device}")
    #device = "/dev/vda"
    #detected_devices=$(lsblk -no NAME,SIZE,TYPE | grep disk | tr -s " " | cut -d " " -f 1)

# TODO: verify the device exists

boot = get("settings.install.boot")
if boot != "efi":
    todo("settings.install.boot")
if boot == "efi":
    # TODO: move the gpt code here
    pass

mode = get("settings.install.mode")
#mountpoint = systemp("mktemp -d")
mountpoint = "/mnt"

# wipe the existing partition tables
do(f"wipefs {device} -af")

cmd = f"yes | parted {device}"
# partition table
do(f"{cmd} mklabel gpt")
# boot partition
do(f"{cmd} mkpart boot 0 512M")
do(f"mkfs.vfat {device}1")
do(f"{cmd} set 1 boot on")

# TODO: de-duplicate
fs = get("settings.install.filesystem")

# no luks/lvm
if mode == "simple":
    # position of next partition in the disk
    next_offset = 512
    next_index = 2
    # swap partition
    swap = getswap("partition")
    if swap:
        do(f"{cmd} mkpart swap {next_offset}M {next_offset + swap}M")
        do(f"mkswap {device}{next_index}")
        next_offset += swap
        next_index += 1
    # root partition
    do(f"{cmd} mkpart root {next_offset}M 100%")
    # TODO: force with -f (btrfs) or prompt for confirmation (use a setting for that)
    do(f"mkfs.{fs} {device}{next_index}")
    do(f"mount -t {fs} {device}{next_index} {mountpoint}")

    # install
    do(f"mkdir -p {mountpoint}/boot/efi")
    do(f"mount -t vfat {device}1 {mountpoint}/boot/efi")
    do(f"BOOTLOADER=grub USE_EFI=1 setup-disk -m sys {mountpoint}")
elif mode == "full":
    # luks+lvm
    do(f"{cmd} mkpart crypt 512M 100%")
    # TODO: check if cryptsetup works from the first time (might be a quantum bug, fixed by upgrading)
    do("apk add cryptsetup")
    # TODO: check if the partition table is refreshed
    # TODO: add a passphrase (prompt the user ?)
    passphrase = "user"
    do(f"echo -e 'YES\n{passphrase}' | cryptsetup luksFormat {device}2")
    do(f"echo '{passphrase}' | cryptsetup open {device}2 custom_crypt")
    do("apk add lvm2")
    do(f"pvcreate /dev/mapper/custom_crypt")
    do(f"vgcreate custom /dev/mapper/custom_crypt")
    # create swap
    swap = getswap("partition")
    if swap:
        do(f"lvcreate --size {swap}M --name swap custom")
        do(f"mkswap /dev/custom/swap")
    # create secondary (encrypted) boot
    do(f"lvcreate --size 2G --name boot custom")
    do(f"mkfs.ext4 /dev/custom/boot")
    # create root
    do(f"lvcreate -l 100%FREE --name root custom")
    do(f"mkfs.{fs} /dev/custom/root")

    # prepare filesystem
    do(f"mount -t ext4 /dev/custom/root {mountpoint}")
    do(f"mkdir {mountpoint}/boot")
    do(f"mount -t ext4 /dev/custom/boot {mountpoint}/boot")
    do(f"mkdir {mountpoint}/boot/efi")
    do(f"mount -t vfat {device}1 {mountpoint}/boot/efi")

    # TODO: solution attempts for the current problem (/lib/modules missing from the chroot)
    # TODO: read the error messages
    # TODO: test with the installer (by going up to the level where things fail)
    # TODO: try to reproduce the same environment as essayer de reproduire le même environnement (alpine pur, mêmes paquets,...)
    # TODO: if this doesn't work, try with MBR ? (or call for help on a native alpine with efi+luks+lvm)
    do(f"setup-disk -m sys /mnt")
else:
    error_unknown("settings.install.mode")

do(f"mkdir -p {mountpoint}/boot/efi")
do(f"mount -t vfat {device}1 {mountpoint}/boot/efi")

# Alpine wiki: LVM on LUKS
# info: GRUB required for gpt, syslinux better for mbr
# test: boot partition with ext4 ? (in MBR only, parted mkpart uses type=ext4 for boot partition in the documentation)
# TODO: make a second (encrypted) boot partition
# (both root and boot partitions in luks+lvm)
# TODO: dd if=/dev/urandom of=/dev/sda2 bs=1M before making the luks volume
#   (make this a setting to avoid writing 50G in a VM)
# TODO: 2GB boot partition (make this boot partition before the root one)
# TODO: format root as ext4
# TODO: apk add dosfstools ?
# TODO: test: mkfs.fat -F32 /dev/vda1 (efi boot efi) instead of vfat
# TODO: mount encrypted boot on /mnt/boot, THEN /dev/vda1 on /dev/boot/efi
# TODO: setup-disk -m sys /mnt

# TODO: fstab (add manually):
# /dev/custom/swap  swap    swap    defaults    0 0


# TODO: manually add cryptsetup and keymap to "features" in /mnt/etc/mkinitfs/mkinitfs.conf
#   -> already done, not needed
    # TODO: check if this becomes needed when setup-keymap is done automatically, in the chroot, after setup-disk
# added cryptkey (to use a keyfile in cryptsetup and only type the passphrase once) and kms (for the passphrase prompt during boot)

# TODO: test mkinitfs -L and see what features are missing: ext4, lvm, usb,...
# TODO: mkinitfs -c /mnt/etc/mkinitfs/mkinitfs.conf -b /mnt $(ls /mnt/lib/modules)

# the problem: /mnt/lib/modules does not exist, and mkinitfs fails

# TODO: check how to install a bootloader (grub for efi)
# TODO: grub instructions:
# # use a keyfile to avoid repeating the passphrase
# touch /mnt/crypto_keyfile.bin # specific/hardcoded path
# chmod 600 /mnt/crypto_keyfile.bin
# dd bs=512 count=4 if=/dev/urandom of=/mnt/crypto_keyfile.bin
# cryptsetup luksAddKey /dev/vda2 /mnt/crypto_keyfile.bin
# mount -t proc

do(f"BOOTLOADER=grub USE_EFI=1 setup-disk -m sys {mountpoint}")


# ======
# chroot wrappers
# ======

# TODO: remove installed packages (pkg.installed) in chroot

# TODO: optimize chroot ?
# with chroot(/mnt) as system:
# systemp() -> execute after end of block ?
# (efficient, but cannot parse return values)

def chroot(cmd, stdin=None, stderr=False):
    return systemp(f"arch-chroot {mountpoint} {cmd}", stdin, stderr=stderr)

def chadd(pkg):
    out, code = chroot(f"apk add {pkg}")
    if verbose:
        print(out)

def chdel(pkg):
    out, code = chroot(f"apk del {pkg}")
    if verbose:
        print(out)

def chrcstart(service):
    chroot(f"rc-service {service} start")

def chrcstop(service):
    chroot(f"rc-service {service} stop")

def chrcadd(service):
    chroot(f"rc-update add {service}")

def chrcdel(service):
    chroot(f"rc-update del {service}")

def unknown(setting):
    value = get(setting)
    error(setting,"unrecognized setting: {value}")


#=====================
# chroot system configuration
#=====================

# lock root account
chroot("passwd -l root")

# TODO: setup username, apk repos, timezone,...

# TODO: check if apkrepos are setup already or not (they need to be)
chroot("apk update")
chroot("apk upgrade")

# system features

# network is already taken care of by the init script
# but has to be enabled after reboot
if get("features.system.networkmanager"):
    chrcadd("networkmanager boot")

if get("features.system.seedrng"):
    chrcadd("seedrng")

if get("features.system.acpid"):
    chrcadd("acpid")
    chroot("rc-update add acpid")

if get("features.system.udisks2"):
    chadd("udisks2")

if get("features.system.polkit"):
    chadd("polkit")
    chrcadd("polkit")
    chrcstart("polkit")


# dev features

if get("features.dev.docker"):
    chadd("docker")
    chadd("docker-compose")
    chrcadd("docker")
    # this is what usually requires logging out to setup rootless docker management
    chroot(f"adduser {username} docker")

if get("features.dev.guix"):
    print("guix: not implemented (skipping)")

ssh = get("features.dev.ssh")
if ssh == "openssh":
    chroot("setup-sshd openssh")
elif ssh == "none":
    print("skipping ssh server")
else:
    unknown("features.dev.ssh")


# TODO: check the packages, vim and nano must be removed instead of being added
for pkg in ["curl", "wget", "nmap", "jq", "yq", "arch-install-scripts", "tmux", "vim", "nano"]:
    if get(f"features.dev.{pkg}"):
        chadd(pkg)

if get("features.dev.man"):
    print("man: not implemented")

if get("features.dev.archroot"):
    # error, does not work yet
    #wget --no-check-certificate https://raw.github.com/tokland/arch-bootstrap/master/arch-bootstrap.sh
    ##mkdir archroot
    ## mkdir chroot64
    #bash arch-bootstrap.sh -a x86_64 # archroot
    print("archroot: not implemented")
if get("settings.system.shell") == "zsh":
    chadd("zsh")
    chadd("alpine-zsh-config")
    # every user will use zsh
    chroot("sed -i 's/ash/zsh/g' /etc/passwd")

# user features
if get("features.user.firefox"):
    chadd("firefox")

if get("features.user.flatpak"):
    chadd("flatpak")

if get("features.user.libreoffice"):
    chadd("libreoffice")

# removed for now:
# btop
# gcompat
# cryptsetup


if get("features.system.polkit"):
    # TODO: test
    #mkdir -p /etc/polkit/rules.d
    do(f"mv {installconf}/etc/polkit-1/rules.d/* /mnt/etc/polkit-1/rules.d/")

# graphical interface
preset = get("features.graphics.preset")
if preset == "river":
    print("river window manager")
    chadd("river")
    chrcstart("seatd")
    chrcadd("seatd boot")
    chroot(f"adduser {username} seat")
    chadd("xwayland")
    # udev is already setup by the init script (used by networkmanager)
    #setup-devd udev

    # river config
    userconfig = f"/mnt/home/{username}/.config"
    #riverconf = f"{userconfig}/river"
    do(f"mkdir -p {riverconf}")

    do(f"cp {installconf}/configs/river/river-init {userconfig}/river/init")
    do(f"chmod +x {userconfig}/river/init")

    launcher = get("graphics.river.launcher")
    if launcher == "bemenu":
        chadd("bemenu")
    elif launcher == "wofi":
        todo("graphics.river.launcher")
    elif launcher == "none":
        print("skipping river launcher")
    else:
        unknown("graphics.river.launcher")

    bar = get("graphics.river.bar")
    if bar == "wayland":
        do(f"mkdir {userconfig}/waybar")
        do(f"cp {installconf}/configs/river/waybar-config.json {userconfig}/waybar/config")
        chadd("waybar")
    elif bar == "none":
        pass
    else:
        unknown("graphics.river.bar")

    do(f"cp {installconf}/configs/river/xdg-profile.sh /mnt/etc/profile.d/xdg-runtime-dir.sh")

    # TODO: chmod +x ?


    chadd("font-dejavu")

    background = get("graphics.river.background")
    if background == "swaybg":
        chadd("swaybg")
    elif background == "none":
        pass
    else:
        unknown("graphics.river.background")

    terminal = get("graphics.river.terminal")
    if terminal == "foot":
        chadd("foot")
    elif terminal == "none":
        pass
    else:
        unknown("graphics.river.terminal")

    # needed for waybar
    chadd("dbus")
    chadd("dbus-x11")

    explorer = get("graphics.river.explorer")
    if explorer == "thunar":
        chadd("thunar")
    elif explorer == "none":
        pass
    else:
        unknown("graphics.river.explorer")

    login = get("graphics.river.login")
    if login == "greetd-wlgreet":
        print("setting up greetd session manager")
        chadd("greetd-wlgreet")
        systemp(f"cp {installconf}/configs/river/greetd-config.toml /mnt/etc/greetd/config.toml")
        systemp(f"cp {installconf}/configs/river/river-wlgreet-config /mnt/etc/greetd/river-wlgreet-config")

        systemp("chmod +x /mnt/etc/greetd/river-wlgreet-config")
        #chmod u+x /etc/greetd/river-wlgreet-config
        #chown greetd /etc/greetd/river-wlgreet-config
        chroot("adduser greetd seat")

        # TODO: carefully test before doing this
        # (every failed test interrupts the terminal)
        #rc-service greetd start
        chrcadd("greetd")
    elif login == "none":
        pass
    else:
        unknown("graphics.river.login")


elif preset == "xfce":
    chroot("setup-xorg-base")
    chadd("xfce4 xfce4-terminal xfce4-screensaver lightdm-gtk-greeter")
    #rc-service lightdm start
    chrcadd("lightdm")
    # replace lightdm keyboard
#    	layout=$(config graphics.options.xfce.xkeyboard.layout)
#    	variant=$(config graphics.options.xfce.xkeyboard.variant)
#    	if ! [ "$layout" = "none" ]
    chadd("setxkbmap")
    old = "#display-setup-script="
    new = f"display-setup-script=setxkbmab {layout} {variant}"
    systemp(f"sed -i 's/{old}/{new}/g' /mnt/etc/lightdm/lightdm.conf")
    # udev is already setup by the init script
    #setup-devd udev
else:
    unknown("graphics.preset")


# remove unused (installer) packages
if not get("features.system.networkmanager"):
    chrcdel("networkmanager boot")
    chrcstop("networkmanager")
    chdel("networkmanager")

# TODO: remove python

for pkg in ["vim", "nano", "yq"]:
    if not get(f"features.dev.{pkg}"):
        chdel(pkg)

# systemp("yes | setup-disk -m sys /dev/vda")

